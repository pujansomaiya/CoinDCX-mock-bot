#!/usr/bin/env python3
"""
TestTrade18_Bot ‚Äî CoinDCX mock trading Telegram bot (single file)

Behavior:
- Trades these pairs (mock): BTCINR, ETHINR, MATICINR, XRPINR, SOLINR, DOGEINR
- Position size: 5% - 10% of current virtual balance (INR)
- Leverage: random integer between 5x and 10x (applied to simulated PnL calculation)
- Take Profit: +3% from entry (unleveraged %; leverage affects $PnL)
- Stop Loss: -5% from entry
- Auto-trades every 5 minutes (configurable)
- Uses CoinDCX public price endpoint (no API keys required)
- Persists state (balance, trades, engine_weights) to SQLite `testtrade18.db`
- Sends Telegram messages per open/close and hourly summary
- DRY RUN / mock trading only: NO real orders, NO exchange keys required

Environment:
- TELEGRAM_TOKEN (required) ‚Äî put your bot token into env/secrets
- TELEGRAM_CHAT_ID (optional) ‚Äî default uses 7206453888 (your chat id)
- CYCLE_SECONDS (optional) ‚Äî default 300 (5 minutes)

Usage:
- Run locally: `pip install -r requirements.txt` then `python testtrade18_bot.py`
- Replit: add TELEGRAM_TOKEN to Secrets and Run
- Render: add TELEGRAM_TOKEN in Environment and use the start command above
"""

import os
import time
import json
import math
import random
import sqlite3
import traceback
from datetime import datetime, timedelta
import requests

# ---------------- CONFIG ----------------
PAIRS = ["BTCINR", "ETHINR", "MATICINR", "XRPINR", "SOLINR", "DOGEINR"]
DB_FILE = "testtrade18.db"
START_BALANCE = float(os.getenv("START_BALANCE", "10000"))  # INR starting capital
MIN_POS_PCT = float(os.getenv("MIN_POS_PCT", "5.0"))   # % of balance
MAX_POS_PCT = float(os.getenv("MAX_POS_PCT", "10.0"))  # % of balance
MIN_LEV = int(os.getenv("MIN_LEV", "5"))               # leverage min (x)
MAX_LEV = int(os.getenv("MAX_LEV", "10"))              # leverage max (x)
TP_PCT = float(os.getenv("TP_PCT", "3.0"))             # take profit percent (unleveraged)
SL_PCT = float(os.getenv("SL_PCT", "5.0"))             # stop loss percent (unleveraged)
CYCLE_SECONDS = int(os.getenv("CYCLE_SECONDS", "300")) # default 5 minutes
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "")       # REQUIRED
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "7206453888")
# Simple stub agents count (for future extension)
ENGINE_NAMES = ["GPT-5","Grok","Gemini","Claude","DeepSeek","Perplexity","MetaAI","Mistral","Falcon"]

COINDCX_TRADE_HISTORY = "https://public.coindcx.com/market_data/trade_history/?pair={pair}&limit=1"

# ---------------- Safety checks ----------------
if not TELEGRAM_TOKEN:
    print("WARNING: TELEGRAM_TOKEN not set in environment. Telegram messaging will be disabled.")
# Always operate in mock mode ‚Äî DO NOT place real orders.
LIVE_ORDERS = False

# ---------------- Utilities ----------------
def now_iso():
    return datetime.utcnow().isoformat()

def pretty_inr(x):
    try:
        return f"‚Çπ{x:,.2f}"
    except:
        return str(x)

def send_telegram(text):
    if not TELEGRAM_TOKEN:
        print("[TG disabled] " + text)
        return
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        payload = {"chat_id": TELEGRAM_CHAT_ID, "text": text}
        r = requests.post(url, json=payload, timeout=10)
        if r.status_code != 200:
            print("Telegram send failed:", r.status_code, r.text)
    except Exception as e:
        print("Telegram exception:", e)

# ---------------- Database ----------------
def init_db():
    conn = sqlite3.connect(DB_FILE, check_same_thread=False)
    cur = conn.cursor()
    cur.executescript("""
    CREATE TABLE IF NOT EXISTS meta (k TEXT PRIMARY KEY, v TEXT);
    CREATE TABLE IF NOT EXISTS trades (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        time TEXT,
        pair TEXT,
        side TEXT,
        entry REAL,
        exit REAL,
        pos_inr REAL,
        leverage INTEGER,
        pnl_inr REAL,
        pnl_pct REAL,
        result TEXT,
        details TEXT
    );
    CREATE TABLE IF NOT EXISTS engine_weights (engine TEXT PRIMARY KEY, weight REAL);
    """)
    # init balance
    cur.execute("INSERT OR IGNORE INTO meta (k,v) VALUES ('balance', ?)", (str(START_BALANCE),))
    # init engine weights
    for e in ENGINE_NAMES:
        cur.execute("INSERT OR IGNORE INTO engine_weights (engine, weight) VALUES (?, ?)", (e, 1.0))
    conn.commit()
    return conn

conn = init_db()

def get_balance():
    cur = conn.cursor()
    cur.execute("SELECT v FROM meta WHERE k='balance'")
    row = cur.fetchone()
    return float(row[0]) if row else START_BALANCE

def set_balance(val):
    cur = conn.cursor()
    cur.execute("UPDATE meta SET v=? WHERE k='balance'", (str(float(val)),))
    conn.commit()

def save_trade_record(rec):
    cur = conn.cursor()
    cur.execute("""INSERT INTO trades (time,pair,side,entry,exit,pos_inr,leverage,pnl_inr,pnl_pct,result,details)
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (rec["time"], rec["pair"], rec["side"], rec["entry"], rec["exit"], rec["pos_inr"],
                 rec["leverage"], rec["pnl_inr"], rec["pnl_pct"], rec["result"], json.dumps(rec.get("details",{}))))
    conn.commit()
    return cur.lastrowid

# ---------------- Market data ----------------
def fetch_last_price(pair):
    url = COINDCX_TRADE_HISTORY.format(pair=pair)
    try:
        r = requests.get(url, timeout=10)
        data = r.json()
        if isinstance(data, list) and len(data)>0:
            # Safe extraction ‚Äî many endpoints return 'price' as string under keys 'price' or 'p'
            item = data[0]
            price = item.get("price") or item.get("p") or item.get("price")
            return float(price)
        # fallback
        if isinstance(data, dict) and "price" in data:
            return float(data["price"])
    except Exception as e:
        print(f"[price error] {pair} ->", e)
    return None

# ---------------- Agent stubs (voting) ----------------
# Currently simple random stubs ‚Äî kept so you can later plug real LLM calls.
def stub_agent_vote(engine, pair):
    r = random.random()
    if r < 0.40:
        vote = "buy"
    elif r < 0.80:
        vote = "sell"
    else:
        vote = "hold"
    confidence = round(random.uniform(0.5, 0.95), 2)
    return {"engine": engine, "vote": vote, "confidence": confidence}

def collect_votes(pair):
    votes = []
    for e in ENGINE_NAMES:
        try:
            votes.append(stub_agent_vote(e, pair))
        except Exception:
            votes.append({"engine": e, "vote": "hold", "confidence": 0.5})
    return votes

def majority_decision(votes):
    counts = {"buy":0,"sell":0,"hold":0}
    for v in votes:
        counts[v["vote"]] += 1
    maxv = max(counts.values())
    winners = [k for k,v in counts.items() if v==maxv]
    if len(winners) != 1:
        return {"decision":"hold", "counts":counts}
    return {"decision": winners[0], "counts":counts}

# ---------------- Simulation functions ----------------
open_positions = {}  # trade_id -> pos
trade_seq = 0

def open_position(pair, side, entry_price, pos_inr, leverage, votes):
    """
    Prepare a simulated position and persist minimal info in memory.
    """
    global trade_seq
    trade_seq += 1
    qty = pos_inr / entry_price if entry_price>0 else 0.0
    tp_price = entry_price * (1 + TP_PCT/100.0) if side == "long" else entry_price * (1 - TP_PCT/100.0)
    sl_price = entry_price * (1 - SL_PCT/100.0) if side == "long" else entry_price * (1 + SL_PCT/100.0)
    pos = {
        "id": trade_seq,
        "pair": pair,
        "side": side,
        "entry": entry_price,
        "qty": qty,
        "pos_inr": pos_inr,
        "leverage": leverage,
        "tp": tp_price,
        "sl": sl_price,
        "open_time": now_iso(),
        "votes": votes
    }
    open_positions[trade_seq] = pos
    msg = (f"üîµ OPEN {side.upper()} {pair} | Entry {pretty_inr(entry_price)} | Size {pretty_inr(pos_inr)} "
           f"| Lev {leverage}x | TP {TP_PCT}% | SL {SL_PCT}% | id {trade_seq}")
    print(msg)
    send_telegram(msg)
    return pos

def close_position(pos_id, exit_price, reason="tp/sl/timeout"):
    pos = open_positions.get(pos_id)
    if not pos:
        return None
    entry = pos["entry"]
    side = pos["side"]
    pos_inr = pos["pos_inr"]
    leverage = pos["leverage"]

    # compute % move (unleveraged)
    if side == "long":
        pnl_pct = (exit_price - entry) / entry * 100.0
    else:
        pnl_pct = (entry - exit_price) / entry * 100.0

    # PnL in INR = notional * (pnl_pct / 100)
    # Notional = pos_inr * leverage
    notional = pos_inr * leverage
    pnl_inr = notional * (pnl_pct / 100.0)

    result = "win" if pnl_inr > 0 else "loss"
    rec = {
        "time": now_iso(),
        "pair": pos["pair"],
        "side": side,
        "entry": entry,
        "exit": exit_price,
        "pos_inr": pos_inr,
        "leverage": leverage,
        "pnl_inr": round(pnl_inr,2),
        "pnl_pct": round(pnl_pct,4),
        "result": result,
        "details": pos
    }
    save_trade_record(rec)

    # update virtual balance
    bal = get_balance()
    new_bal = bal + pnl_inr
    set_balance(new_bal)

    msg = f"{'‚úÖ' if pnl_inr>0 else '‚ùå'} CLOSE id {pos_id} {pos['pair']} | Exit {pretty_inr(exit_price)} | PnL {pretty_inr(pnl_inr)} | Bal {pretty_inr(new_bal)} | reason {reason}"
    print(msg)
    send_telegram(msg)

    # remove open position
    del open_positions[pos_id]
    return rec

# ---------------- Weight update (simple) ----------------
def update_weights_from_trade(rec):
    # Simple weight update: engines that voted for winning side get slight boost
    try:
        votes = rec.get("details", {}).get("votes", [])
        pnl = float(rec.get("pnl_inr", 0.0))
        if pnl == 0:
            return
        profitable_side = "buy" if pnl > 0 else "sell"
        cur = conn.cursor()
        for v in votes:
            engine = v.get("engine")
            vote = v.get("vote")
            conf = float(v.get("confidence", 0.5))
            cur.execute("SELECT weight FROM engine_weights WHERE engine=?", (engine,))
            row = cur.fetchone()
            old = float(row[0]) if row else 1.0
            align = 1.0 if vote == profitable_side else -1.0
            delta = WEIGHT_LR * align * conf * math.sqrt(abs(pnl) + 1.0)
            neww = max(0.1, min(20.0, old * math.exp(delta)))
            cur.execute("UPDATE engine_weights SET weight=? WHERE engine=?", (neww, engine))
        conn.commit()
    except Exception:
        print("weight update failed:", traceback.format_exc())

# ---------------- Main loop ----------------
def main_loop():
    print("Starting TestTrade18_Bot mock trading loop ‚Äî pairs:", ", ".join(PAIRS))
    send_telegram("üîî TestTrade18_Bot mock trading started (auto mode).")
    cycle = 0
    last_hour = datetime.utcnow().hour

    while True:
        try:
            cycle += 1
            # 1) check open positions for TP/SL
            for pid, pos in list(open_positions.items()):
                price_now = fetch_last_price(pos["pair"])
                if price_now is None:
                    continue
                # TP
                if (pos["side"] == "long" and price_now >= pos["tp"]) or (pos["side"] == "short" and price_now <= pos["tp"]):
                    rec = close_position(pid, pos["tp"], reason="TP")
                    update_weights_from_trade(rec)
                # SL
                elif (pos["side"] == "long" and price_now <= pos["sl"]) or (pos["side"] == "short" and price_now >= pos["sl"]):
                    rec = close_position(pid, pos["sl"], reason="SL")
                    update_weights_from_trade(rec)

            # 2) attempt new trades for each symbol if few positions open
            # limit open positions to avoid overtrading: at most len(PAIRS) open
            for pair in PAIRS:
                if len(open_positions) >= len(PAIRS):
                    break
                # collect votes
                votes = collect_votes(pair)
                agg = majority_decision(votes)
                decision = agg["decision"]  # 'buy' 'sell' or 'hold'
                if decision in ("buy", "sell"):
                    side = "long" if decision == "buy" else "short"
                    price = fetch_last_price(pair)
                    if price is None:
                        continue
                    # position size: percent of balance
                    bal = get_balance()
                    pos_pct = random.uniform(MIN_POS_PCT, MAX_POS_PCT) / 100.0
                    pos_inr = round(bal * pos_pct, 2)
                    leverage = random.randint(MIN_LEV, MAX_LEV)
                    pos = open_position(pair, side, price, pos_inr, leverage, votes)
                    # attach to DB later on close
                    time.sleep(0.2)

            # hourly summary
            now = datetime.utcnow()
            if now.hour != last_hour:
                last_hour = now.hour
                bal = get_balance()
                msg = (f"‚è± Hourly Summary {now.isoformat()}\nBalance: {pretty_inr(bal)}\nOpen positions: {len(open_positions)}\nTotal trades recorded: {count_trades()}")
                print(msg)
                send_telegram(msg)

            time.sleep(CYCLE_SECONDS)
        except Exception as e:
            print("Runtime exception:", e, traceback.format_exc())
            time.sleep(5)

# ---------------- Small helpers ----------------
def count_trades():
    cur = conn.cursor()
    cur.execute("SELECT COUNT(*) FROM trades")
    row = cur.fetchone()
    return int(row[0]) if row else 0

# ---------------- Entrypoint ----------------
if __name__ == "__main__":
    try:
        main_loop()
    except KeyboardInterrupt:
        print("Stopped by user.")
        send_telegram("üõë TestTrade18_Bot stopped by user.")
        conn.close()